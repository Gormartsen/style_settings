<?php
define('STYLE_SETTINGS_STYLESHEET_DIR', 'public://style_settings/');

/**
 * @file.
 * Use any (custom) theme setting or Drupal variable in any of your theme or
 * module style sheets (see https://drupal.org/project/style_settings).
 */

/**
 * Implements hook_css_alter().
 */
function style_settings_css_alter(&$css) {
  // When _drupal_flush_css_js() changes the 'css_js_query_string', we will use
  // this as a directive to bypass the caching of the rewritten paths.
  $css_js_query_string_changed = variable_get('css_js_query_string', '0') != variable_get('style_settings_last_css_js_query_string', '0');
  // Get all themes that use Style (CSS) Settings.
  // They got 'soft_dependencies[] = style_settings' in their '.info' file.
  $themes = array_keys(array_filter(system_get_info('theme'), function($ar) {
    if (isset($ar['soft_dependencies'])) {
      return in_array('style_settings', $ar['soft_dependencies']);
    }
    else (isset($ar['dependencies'])) {
      return in_array('style_settings', $ar['dependencies']);
    }
  }));
  // Process each theme that has a soft-dependency.
  foreach ($themes as $theme) {
    if (style_settings_theme_exists($theme)) {
      $path_to_theme = drupal_get_path('theme', $theme);
      // Process each style sheet of a theme.
      foreach ($css as $path => $stylesheet) {
        if (file_exists($path) && strstr($path, $path_to_theme)) {
          if ($new_path = style_settings_rewrite($path, $css_js_query_string_changed)) {
            $relative_uri = file_create_relative_uri($new_path);
            $css[$relative_uri] = $css[$path];
            $css[$relative_uri]['data'] = $relative_uri;
            unset($css[$path]);
          }
        }
      }
    }
  }

  // Get all modules that use Style (CSS) Settings.
  // They got 'soft_dependencies[] = style_settings' in their '.info' file.
  $modules = array_keys(array_filter(system_get_info('module'), function($ar) {
    if (isset($ar['soft_dependencies'])) {
      return in_array('style_settings', $ar['soft_dependencies']);
    }
    else (isset($ar['dependencies'])) {
      return in_array('style_settings', $ar['dependencies']);
    }
  }));
  // Process each module that has a soft-dependency.
  foreach ($modules as $module) {
    if (module_exists($module)) {
      $path_to_module = drupal_get_path('module', $module);
      // Process each style sheet of a module.
      foreach ($css as $path => $stylesheet) {
        if (file_exists($path) && strstr($path, $path_to_module)) {
          if ($new_path = style_settings_rewrite($path, $css_js_query_string_changed)) {
            $relative_uri = file_create_relative_uri($new_path);
            $css[$relative_uri] = $css[$path];
            $css[$relative_uri]['data'] = $relative_uri;
            unset($css[$path]);
          }
        }
      }
    }
  }
  if ($css_js_query_string_changed) {
    variable_set('style_settings_last_css_js_query_string', variable_get('css_js_query_string', '0'));
  }
}

/**
 * Rewrite a style sheet and return the path to the rewritten one.
 */
function style_settings_rewrite($path, $reset = FALSE) {
  // Get the active theme and all available persistent variables ($conf).
  global $theme_key, $conf;
  // Caching hashed 'new paths' as it is expensive to calculate these values.
  $cid = 'style_settings_'. $path;
  $new_path_cached = cache_get($cid);
  $new_path = isset($new_path_cached->data) ? $new_path_cached->data : FALSE;
  // We need a new unique key (and rewrite) if the original CSS file changed.
  $change = (string) @filectime($path);
  // Detect remote files where 'filectime()' returns FALSE.
  $remote = empty($change);
  // Exclude variables that change on each page load.
  unset($conf['drupal_css_cache_files']);
  unset($conf['drupal_js_cache_files']);
  if (!$new_path || $reset) {
    // Get all settings of the current active theme.
    $settings = variable_get('theme_' . $theme_key . '_settings', array());
    // Generate a unique key based on theme settings, variables and file date.
    $checksum  = md5(serialize($settings) . serialize($conf) . $change);
    // Generate the filename for the customized CSS file.
    $new_path  = STYLE_SETTINGS_STYLESHEET_DIR . $checksum . '.' . basename($path);
    cache_set($cid, $new_path);
  }
  // Generate the customized CSS file itself if it doesn't exist yet.
  if ($remote || !file_exists($new_path)) {
    $realpath = drupal_realpath($new_path);
    $dirname = dirname($realpath);
    file_prepare_directory($dirname, FILE_CREATE_DIRECTORY);
    $old_data = file_get_contents(file_create_url($path));

    // Prefix all paths, ignoring absolute paths.
    _drupal_build_css_path(NULL, base_path() . dirname($path) . '/');
    $new_data = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $old_data);

    // Replace all custom css.
    $new_data = preg_replace_callback('/\/\*\s*(setting|variable)\s*:\s*([a-z0-9_]+)\s*\*\/(.*)\/\*\s*.*\s*\*\//iU', 'style_settings_replace', $new_data);

    file_unmanaged_save_data($new_data, $new_path, FILE_EXISTS_REPLACE);
  }

  // Cleanup leftover files.
  $generated_files = glob(drupal_realpath(STYLE_SETTINGS_STYLESHEET_DIR) . '/*');
  $fileinfo = pathinfo($path);

  foreach ($generated_files as $generated_file) {
    if (strstr($generated_file, $fileinfo['basename']) && $generated_file != drupal_realpath($new_path)) {
      file_unmanaged_delete($generated_file);
    }
  }

  // Return the new path if the file exists.
  if (file_exists($new_path)) {
    return $new_path;
  }
  else {
    return FALSE;
  }
}

/**
 * Callback to replace custom css tags.
 */
function style_settings_replace($matches) {
  global $theme_key;

  $type      = $matches[1];
  $name      = $matches[2];
  $original  = $matches[3];

  // Cache settings for next calls.
  if ($type == 'setting') {
    $setting = theme_get_setting($name);
  }

  // Variable.
  if ($type == 'variable') {
    $replacement = variable_get($name, NULL);

    if (!$replacement || !(is_string($replacement) || is_numeric($replacement))) {
      return $original;
    }
  }
  // Theme setting.
  else {
    $replacement = $setting;

    if (!$replacement) {
      return $original;
    }
  }

  // Since a comment cannot be in url(), we have to add this around the
  // replacement (if the user doesn't).
  if (preg_match('/url\(.*\)/i', $original) && !preg_match('/url\(.*\)/i', $replacement)) {

    // Prefix path, ignoring absolute paths.
    if (!preg_match('/^([a-z]+:|\/+)/', $replacement)) {
      $replacement = base_path() . $replacement;
    }

    $replacement = 'url(\'' . $replacement . '\')';
  }

  return $replacement;
}

/**
 * Callback for creating a relative uri from a streamwrapper.
 */
function file_create_relative_uri($path) {
  global $base_url;
  $url = file_create_url($path);
  $relative_uri = str_replace($base_url . '/', '', $url);

  return $relative_uri;
}

/**
 * Like Drupal's core 'module_exists()' but for enabled themes.
 */
function style_settings_theme_exists($theme_name) {
  $themes = list_themes();
  return isset($themes[$theme_name]) && $themes[$theme_name]->status == 1;
}

/**
 * Implements hook_element_info().
 */
function style_settings_element_info() {
  $colornames = l(t('valid color names'), 'https://en.wikipedia.org/wiki/Web_colors#X11_color_names', array(
    'attributes' => array(
      'title' => t('Web colors - Wikipedia, the free encyclopedia'),
      'target' => '_blank',
    ),
  ));
  $types['style_settings_colorpicker'] = array(
    '#default_value' => '',
    '#input' => TRUE,
    '#theme' => array('textfield'),
    '#theme_wrappers' => array('form_element'),
    '#autocomplete_path' => FALSE,
    '#element_validate' => array('style_settings_color_validate'),
    '#type' => 'textfield',
    '#size' => 12,
    '#maxlength' => 20,
    '#description' => t('Also shorthand (like #fff) and !colornames are accepted.', array('!colornames' => $colornames)),
    '#suffix' => '<div class="style_settings-picker"></div>',
    '#attributes' => array('class' => array('style_settings-colorpicker')),
    '#attached' => array(
      'library' => array(array('system', 'farbtastic')),
      'js' => array(drupal_get_path('module', 'style_settings') . '/js/style_settings-farbtastic.js'),
    ),
  );
  return $types;
}

/**
 * Validates that the input value matches a hexadecimal color.
 */
function style_settings_color_validate($element, &$form_state) {
  if (!empty($element['#value'])) {
    // Double check that we really have an hexadecimal value.
    if (style_settings_validate_html_color($element['#value'], 1) == FALSE) {
      form_error($element, "<em>". check_plain($element['#value']) ."</em>". t(' is not a valid color'));
    }
  }
}

/* Validates hex color. Checks for a Color Name first to prevent error if a name
 * was entered (optional).
 * $color: the color hex value stirng to Validates $named: (optional), set to
 * 1 or TRUE to first test if a Named color was passed instead of a Hex value.
 */

function style_settings_validate_html_color($color, $named = TRUE) {
  if ($named) {
    $named = array('aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque', 'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown', 'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange', 'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue', 'darkslategray', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'greenyellow', 'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgreen', 'lightgrey', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue', 'lightslategray', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen', 'linen', 'magenta', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen', 'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream', 'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive', 'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod', 'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'red', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue', 'slategray', 'snow', 'springgreen', 'steelblue', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'white', 'whitesmoke', 'yellow', 'yellowgreen');
    if (in_array(strtolower($color), $named)) {
      return $color;
    }
  }
  if (preg_match('/^#[0-9a-f]{3}(?:[0-9a-f]{3})?$/i', $color)) {
    return $color;
  }
  return FALSE;
}
